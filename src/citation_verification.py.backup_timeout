import requests
import logging
import json
from typing import List
import sys

logger = logging.getLogger(__name__)

# from src.models import CitationResult


def verify_citations_with_courtlistener_batch(courtlistener_api_key, citations, text):
    """
    DEPRECATED: Use cluster_citations_unified() with enable_verification=True instead.
    
    This function is deprecated in favor of the unified clustering and verification system.
    The new system provides better batch processing, rate limiting, and integration.
    
    Example:
        from src.unified_citation_clustering import cluster_citations_unified
        clusters = cluster_citations_unified(citations, text, enable_verification=True)
    """
    import warnings
    warnings.warn(
        "verify_citations_with_courtlistener_batch is deprecated. "
        "Use cluster_citations_unified() with enable_verification=True instead.",
        DeprecationWarning,
        stacklevel=2
    )
    if not courtlistener_api_key:
        logger.warning("[CL batch] No API key available")
        return
    if not citations:
        return
    logger.info(f"[CL batch] Verifying {len(citations)} citations with text length: {len(text)}")
    try:
        citations_to_verify = [citation.citation for citation in citations]
        url = "https://www.courtlistener.com/api/rest/v4/citation-lookup/"
        headers = {
            'Authorization': f'Token {courtlistener_api_key}',
            'Content-Type': 'application/json'
        }
        data = {
            'text': ' '.join(citations_to_verify)
        }
        response = requests.post(url, headers=headers, json=data, timeout=30)
        logger.info(f"[CL batch] API response status: {response.status_code}")
        
        if response.status_code == 200:
            try:
                response_data = response.json()
                
                verification_results = {}
                for result in response_data:
                    citation_text = result.get('citation', '')
                    if citation_text:
                        clusters = result.get('clusters', [])
                        if clusters:
                            cluster = clusters[0]
                            verification_results[citation_text] = {
                                'verified': True,
                                'canonical_name': cluster.get('case_name', ''),
                                'canonical_date': cluster.get('date_filed', '')[:4] if cluster.get('date_filed') else '',  # Extract year
                                'url': f"https://www.courtlistener.com{cluster.get('absolute_url', '')}" if cluster.get('absolute_url') else None,
                                'source': 'CourtListener',
                                'court': cluster.get('court', ''),
                                'docket_number': cluster.get('docket_id', '')
                            }
                        else:
                            verification_results[citation_text] = {
                                'verified': False,
                                'source': 'CourtListener',
                                'error': 'No clusters found'
                            }
                    else:
                        verification_results[citation_text] = {
                            'verified': False,
                            'source': 'CourtListener',
                            'error': 'No citation text in response'
                        }
                
                for citation in citations:
                    citation_text = citation.citation
                    if citation_text in verification_results:
                        result = verification_results[citation_text]
                        citation.verified = result.get('verified', False)
                        citation.canonical_name = result.get('canonical_name')
                        citation.canonical_date = result.get('canonical_date')
                        citation.url = result.get('url')
                        citation.source = result.get('source', 'CourtListener')
                        citation.court = result.get('court')
                        citation.docket_number = result.get('docket_number')
                    else:
                        citation.verified = False
                        citation.source = 'CourtListener'
                        citation.error = 'Citation not found in CourtListener response'
                
                
            except json.JSONDecodeError as e:
                logger.error(f"[CL batch] JSON decode error: {e}")
                for citation in citations:
                    citation.verified = False
                    citation.source = 'CourtListener'
                    citation.error = f'JSON parsing error: {e}'
        else:
            logger.error(f"[CL batch] API error status: {response.status_code}")
            for citation in citations:
                citation.verified = False
                citation.source = 'CourtListener'
                citation.error = f'API error: {response.status_code}'
        
        return response
    except Exception as e:
        logger.error(f"[CL batch] Exception: {e}")
        for citation in citations:
            citation.verified = False
            citation.source = 'CourtListener'
            citation.error = f'Exception: {e}'
        return None

def verify_with_courtlistener(courtlistener_api_key, citation, extracted_case_name=None):
    """
    DEPRECATED: Use cluster_citations_unified() with enable_verification=True instead.
    
    This individual verification function is deprecated in favor of the unified
    clustering and batch verification system which is more efficient and accurate.
    
    Issues with individual verification:
    1. Inefficient - makes one API call per citation
    2. No rate limiting coordination
    3. Doesn't benefit from clustering context
    
    Use the unified system instead:
        from src.unified_citation_clustering import cluster_citations_unified
        clusters = cluster_citations_unified(citations, text, enable_verification=True)
    """
    import warnings
    warnings.warn(
        "verify_with_courtlistener is deprecated. "
        "Use cluster_citations_unified() with enable_verification=True for batch verification.",
        DeprecationWarning,
        stacklevel=2
    )
    import warnings
    warnings.warn(
        "This verify_with_courtlistener function in citation_verification.py is DEPRECATED and BROKEN. "
        "Use the correct function from src.courtlistener_verification instead.",
        DeprecationWarning,
        stacklevel=2
    )
    
    print(f"[DEPRECATED WARNING] Using broken verify_with_courtlistener from citation_verification.py for: {citation}")
    print(f"[DEPRECATED WARNING] This function always returns verified=False. Use src.courtlistener_verification.verify_with_courtlistener instead.")
    
    return {
        "canonical_name": None,
        "canonical_date": None,
        "url": None,
        "verified": False,
        "raw": None,
        "source": "DEPRECATED_FUNCTION",
        "error": "This function is deprecated. Use src.courtlistener_verification.verify_with_courtlistener instead."
    }

def verify_citations_with_canonical_service(citations):
    pass

async def verify_citations_with_legal_websearch(citations):
    """
    Verify citations using trusted legal databases with web search as a fallback.
    Only one verifying source is needed per citation.
    
    Args:
        citations: List of CitationResult objects to verify
        
    Returns:
        List of verified CitationResult objects
    """
    from src.comprehensive_websearch_engine import ComprehensiveWebSearchEngine
    import logging
    import asyncio
    
    logger = logging.getLogger(__name__)
    logger.info(f"[VERIFY] Starting legal web search verification for {len(citations)} citations")
    
    if not citations:
        return []
        
    try:
        search_engine = ComprehensiveWebSearchEngine(enable_experimental_engines=True)
        verified_citations = []
        
        search_methods = [
            ('courtlistener', search_engine.search_courtlistener_web),
            ('justia', search_engine.search_justia),
            ('findlaw', search_engine.search_findlaw),
            ('leagle', search_engine.search_leagle),
            ('casetext', search_engine.search_casetext),
            # vlex deprecated due to site blocking and unreliable web scraping
            ('casemine', search_engine.search_casemine),
            ('openjurist', search_engine.search_openjurist),
            ('google_scholar', search_engine.search_google_scholar),
            ('bing', search_engine.search_bing),
            ('duckduckgo', search_engine.search_duckduckgo)
        ]
        
        for citation in citations:
            if hasattr(citation, 'verified') and citation.verified:
                verified_citations.append(citation)
                continue
                
            try:
                logger.info(f"[VERIFY] Processing citation: {citation.citation}")
                case_name = getattr(citation, 'extracted_case_name', None)
                verified = False
                
                for source_name, search_method in search_methods:
                    if not hasattr(search_engine, search_method.__name__):
                        continue
                        
                    try:
                        result = await search_method(citation.citation, case_name)
                        
                        if result and result.get('verified', False):
                            logger.info(f"[VERIFY] Verified {citation.citation} via {source_name}")
                            
                            citation.verified = True
                            citation.source = source_name
                            citation.url = result.get('url', '')
                            
                            trusted_sources = ['courtlistener', 'justia', 'findlaw', 'leagle', 'casetext']
                            reliable_fallbacks = ['google_scholar', 'bing', 'duckduckgo']
                            
                            if source_name in trusted_sources or source_name in reliable_fallbacks:
                                if 'canonical_name' in result and result['canonical_name']:
                                    citation.canonical_name = result['canonical_name']
                                if 'canonical_date' in result and result['canonical_date']:
                                    citation.canonical_date = str(result['canonical_date'])
                                
                                if source_name in reliable_fallbacks:
                                    # canonical_name and canonical_date should only come from verification services
                                    # extracted_case_name and extracted_date should only come from user's document
                                    logger.info(f"[VERIFY] Skipping contamination - keeping canonical and extracted data separate for {citation.citation}")
                            
                            verified = True
                            verified_citations.append(citation)
                            
                            logger.info(f"[VERIFY] SUCCESS: {citation.citation} verified via {source_name}")
                            if citation.canonical_name:
                                logger.info(f"[VERIFY]   Canonical name: {citation.canonical_name}")
                            if citation.canonical_date:
                                logger.info(f"[VERIFY]   Canonical date: {citation.canonical_date}")
                            if citation.url:
                                logger.info(f"[VERIFY]   URL: {citation.url}")
                            
                            break  # Stop after first successful verification
                            
                    except Exception as e:
                        logger.warning(f"[VERIFY] Error searching {source_name} for {citation.citation}: {str(e)}")
                        continue
                
                if not verified:
                    
            except Exception as e:
                logger.error(f"[VERIFY] Error processing citation {citation.citation}: {str(e)}", exc_info=True)
                continue
                
        return verified_citations
        
    except Exception as e:
        logger.error(f"[VERIFY] Fatal error in legal web search verification: {str(e)}", exc_info=True)
        return []