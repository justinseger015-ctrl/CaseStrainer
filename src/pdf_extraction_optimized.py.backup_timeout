"""
Optimized PDF Extraction Module
Addresses performance bottlenecks in the current PDF processing pipeline.
"""

import os
import time
import logging
import re
from typing import Optional, Dict, Any
from pathlib import Path

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class UltraFastPDFExtractor:
    """
    Ultra-fast PDF extraction optimized for speed over comprehensive processing.
    """
    
    def __init__(self):
        self._whitespace_normalize = re.compile(r'\s+')
        self._critical_citation_fix = re.compile(r'(\d+)\s*([USF])\.\s*([SCtEd]+)\.\s*[\n\-]\s*(\d+)')
    
    def extract_text_ultra_fast(self, file_path: str) -> str:
        """
        Ultra-fast PDF extraction with minimal overhead.
        
        Args:
            file_path: Path to PDF file
            
        Returns:
            Extracted text
        """
        start_time = time.time()
        
        if not os.path.exists(file_path):
            return "Error: File not found"
        
        file_size = os.path.getsize(file_path)
        logger.info(f"Ultra-fast extraction: {file_path} ({file_size} bytes)")
        
        text = self._extract_with_pdfminer_fast(file_path)
        if text:
            extraction_time = time.time() - start_time
            logger.info(f"Ultra-fast extraction completed in {extraction_time:.2f}s")
            return text
        
        text = self._extract_with_pypdf2_fast(file_path)
        if text:
            extraction_time = time.time() - start_time
            logger.info(f"Ultra-fast extraction (PyPDF2) completed in {extraction_time:.2f}s")
            return text
        
        return "Error: Extraction failed"
    
    def _extract_with_pdfminer_fast(self, file_path: str) -> Optional[str]:
        """Fast pdfminer extraction with minimal processing."""
        try:
            from pdfminer.high_level import extract_text
            
            text = extract_text(file_path)
            
            if text and text.strip():
                cleaned = self._clean_text_minimal(text)
                logger.info(f"pdfminer extracted {len(cleaned)} characters")
                return cleaned
                
        except Exception as e:
            logger.warning(f"pdfminer extraction failed: {e}")
        
        return None
    
    def _extract_with_pypdf2_fast(self, file_path: str) -> Optional[str]:
        """Fast PyPDF2 extraction with minimal processing."""
        try:
            import PyPDF2
            
            with open(file_path, 'rb') as file:
                reader = PyPDF2.PdfReader(file)
                if reader.is_encrypted:
                    return "Error: Encrypted PDF"
                
                text_parts = []
                for page in reader.pages:
                    page_text = page.extract_text()
                    if page_text:
                        text_parts.append(page_text)
                
                if text_parts:
                    text = " ".join(text_parts)
                    cleaned = self._clean_text_minimal(text)
                    logger.info(f"PyPDF2 extracted {len(cleaned)} characters")
                    return cleaned
                    
        except Exception as e:
            logger.warning(f"PyPDF2 extraction failed: {e}")
        
        return None
    
    def _clean_text_minimal(self, text: str) -> str:
        """Minimal text cleaning for maximum speed."""
        if not text:
            return ""
        
        cleaned = text.strip()
        
        cleaned = self._critical_citation_fix.sub(r'\1 \2.\3. \4', cleaned)
        
        cleaned = self._whitespace_normalize.sub(' ', cleaned)
        
        return cleaned.strip()


class SmartPDFExtractor:
    """
    Smart PDF extraction that chooses the best method based on file characteristics.
    """
    
    def __init__(self):
        self.ultra_fast_extractor = UltraFastPDFExtractor()
    
    def extract_text_smart(self, file_path: str) -> str:
        """
        Smart extraction that chooses the fastest method for the file type.
        
        Args:
            file_path: Path to PDF file
            
        Returns:
            Extracted text
        """
        start_time = time.time()
        
        file_size = os.path.getsize(file_path)
        
        if file_size < 1024 * 1024:
            logger.info(f"Small file detected ({file_size} bytes), using ultra-fast extraction")
            return self.ultra_fast_extractor.extract_text_ultra_fast(file_path)
        
        logger.info(f"Large file detected ({file_size} bytes), using optimized extraction")
        return self._extract_large_file_optimized(file_path)
    
    def _extract_large_file_optimized(self, file_path: str) -> str:
        """Optimized extraction for large files."""
        try:
            from pdfminer.high_level import extract_text
            
            text = extract_text(file_path)
            
            if text and text.strip():
                file_size = os.path.getsize(file_path)
                if file_size > 10 * 1024 * 1024:  # > 10MB
                    cleaned = self._clean_text_minimal(text)
                else:
                    cleaned = self._clean_text_medium(text)
                
                return cleaned
                
        except Exception as e:
            logger.warning(f"Large file extraction failed: {e}")
            return self.ultra_fast_extractor.extract_text_ultra_fast(file_path)
        
        return "Error: Large file extraction failed"
    
    def _clean_text_minimal(self, text: str) -> str:
        """Minimal cleaning for large files."""
        if not text:
            return ""
        
        cleaned = text.strip()
        cleaned = re.sub(r'\s+', ' ', cleaned)
        return cleaned.strip()
    
    def _clean_text_medium(self, text: str) -> str:
        """Medium cleaning for medium files."""
        if not text:
            return ""
        
        cleaned = text.strip()
        
        cleaned = re.sub(r'(\d+)\s*([USF])\.\s*([SCtEd]+)\.\s*[\n\-]\s*(\d+)', r'\1 \2.\3. \4', cleaned)
        
        cleaned = re.sub(r'\s+', ' ', cleaned)
        
        return cleaned.strip()


def extract_text_from_pdf_ultra_fast(file_path: str) -> str:
    """
    Ultra-fast PDF extraction - drop-in replacement for slow methods.
    
    Args:
        file_path: Path to PDF file
        
    Returns:
        Extracted text
    """
    extractor = UltraFastPDFExtractor()
    return extractor.extract_text_ultra_fast(file_path)


def extract_text_from_pdf_smart(file_path: str) -> str:
    """
    Smart PDF extraction - chooses best method based on file characteristics.
    
    Args:
        file_path: Path to PDF file
        
    Returns:
        Extracted text
    """
    extractor = SmartPDFExtractor()
    return extractor.extract_text_smart(file_path)


def benchmark_extraction_methods(file_path: str) -> Dict[str, Any]:
    """
    Benchmark different extraction methods.
    
    Args:
        file_path: Path to PDF file
        
    Returns:
        Dictionary with timing results
    """
    results = {}
    
    start_time = time.time()
    try:
        text = extract_text_from_pdf_ultra_fast(file_path)
        ultra_fast_time = time.time() - start_time
        results['ultra_fast'] = {
            'time': ultra_fast_time,
            'success': not text.startswith('Error:'),
            'text_length': len(text) if text else 0
        }
    except Exception as e:
        results['ultra_fast'] = {
            'time': time.time() - start_time,
            'success': False,
            'error': str(e)
        }
    
    start_time = time.time()
    try:
        text = extract_text_from_pdf_smart(file_path)
        smart_time = time.time() - start_time
        results['smart'] = {
            'time': smart_time,
            'success': not text.startswith('Error:'),
            'text_length': len(text) if text else 0
        }
    except Exception as e:
        results['smart'] = {
            'time': time.time() - start_time,
            'success': False,
            'error': str(e)
        }
    
    return results


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        file_path = sys.argv[1]
        if os.path.exists(file_path):
            print(f"Testing optimized PDF extraction on: {file_path}")
            results = benchmark_extraction_methods(file_path)
            
            for method, result in results.items():
                print(f"\n{method.upper()} EXTRACTION:")
                print(f"  Time: {result['time']:.2f}s")
                print(f"  Success: {result['success']}")
                print(f"  Text Length: {result.get('text_length', 0)}")
                if 'error' in result:
                    print(f"  Error: {result['error']}")
        else:
            print(f"File not found: {file_path}")
    else:
        print("Usage: python pdf_extraction_optimized.py <pdf_file_path>") 