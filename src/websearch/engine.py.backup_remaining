"""
Web Search Engine Module
Comprehensive web search engine for legal citations and case information.
"""

import asyncio
from src.config import DEFAULT_REQUEST_TIMEOUT, COURTLISTENER_TIMEOUT, CASEMINE_TIMEOUT, WEBSEARCH_TIMEOUT, SCRAPINGBEE_TIMEOUT

import aiohttp
import logging
import time
import random
from typing import Dict, List, Any, Optional, Tuple, Set
from urllib.parse import urlparse, quote_plus, urljoin
from datetime import datetime, timedelta
import warnings
import re

from .citation_normalizer import EnhancedCitationNormalizer
from .metadata import SearchEngineMetadata
from .cache import CacheManager
from .predictor import SourcePredictor
from .semantic import SemanticMatcher
from .linkrot import EnhancedLinkrotDetector
from .fusion import ResultFusionEngine
from .ml_predictor import AdvancedMLPredictor
from .error_recovery import AdvancedErrorRecovery
from .analytics import AdvancedAnalytics
from .extractor import ComprehensiveWebExtractor

logger = logging.getLogger(__name__)


class ComprehensiveWebSearchEngine:
    """Comprehensive web search engine for legal citations and case information."""
    
    def __init__(self, enable_experimental_engines=False):
        self.cache_manager = CacheManager()
        self.citation_normalizer = EnhancedCitationNormalizer()
        self.source_predictor = SourcePredictor()
        self.semantic_matcher = SemanticMatcher()
        self.linkrot_detector = EnhancedLinkrotDetector(self.cache_manager)
        self.result_fusion = ResultFusionEngine(self.semantic_matcher)
        self.ml_predictor = AdvancedMLPredictor(self.cache_manager)
        self.error_recovery = AdvancedErrorRecovery(self.cache_manager, self.ml_predictor)
        self.analytics = AdvancedAnalytics(self.cache_manager)
        self.extractor = ComprehensiveWebExtractor()
        
        self.search_engines = {
            'justia': {
                'base_url': 'https://law.justia.com',
                'search_url': 'https://law.justia.com/search',
                'rate_limit': 1.0,
                'enabled': True
            },
            'findlaw': {
                'base_url': 'https://caselaw.findlaw.com',
                'search_url': 'https://caselaw.findlaw.com/search',
                'rate_limit': 1.0,
                'enabled': True
            },
            'courtlistener_web': {
                'base_url': 'https://www.courtlistener.com',
                'search_url': 'https://www.courtlistener.com/search',
                'rate_limit': 2.0,
                'enabled': True
            },
            'leagle': {
                'base_url': 'https://www.leagle.com',
                'search_url': 'https://www.leagle.com/search',
                'rate_limit': 1.5,
                'enabled': True
            },
            'casetext': {
                'base_url': 'https://casetext.com',
                'search_url': 'https://casetext.com/search',
                'rate_limit': 2.0,
                'enabled': True
            },
            'vlex': {
                'base_url': 'https://vlex.com',
                'search_url': 'https://vlex.com/search',
                'rate_limit': 2.0,
                'enabled': True
            },
            'google_scholar': {
                'base_url': 'https://scholar.google.com',
                'search_url': 'https://scholar.google.com/scholar',
                'rate_limit': 3.0,
                'enabled': True
            },
            'bing': {
                'base_url': 'https://www.bing.com',
                'search_url': 'https://www.bing.com/search',
                'rate_limit': 1.0,
                'enabled': True
            },
            'duckduckgo': {
                'base_url': 'https://duckduckgo.com',
                'search_url': 'https://duckduckgo.com/html',
                'rate_limit': 1.0,
                'enabled': True
            }
        }
        
        if enable_experimental_engines:
            self.search_engines.update({
                'openjurist': {
                    'base_url': 'https://openjurist.org',
                    'search_url': 'https://openjurist.org/search',
                    'rate_limit': 2.0,
                    'enabled': True
                },
                'casemine': {
                    'base_url': 'https://www.casemine.com',
                    'search_url': 'https://www.casemine.com/search',
                    'rate_limit': 2.0,
                    'enabled': True
                }
            })
        
        self.last_request_time = {}
        self.request_counts = {}
        
        self.stats = {
            'total_searches': 0,
            'successful_searches': 0,
            'failed_searches': 0,
            'cache_hits': 0,
            'cache_misses': 0,
            'average_response_time': 0.0
        }
    
    def generate_strategic_queries(self, cluster: Dict) -> List[Dict[str, str]]:
        """Generate strategic search queries for a citation cluster."""
        queries = []
        citation = cluster.get('citation', '')
        case_name = cluster.get('case_name', '')
        
        if not citation:
            return queries
        
        citation_variants = self.citation_normalizer.generate_variants(citation)
        
        individual_citations = self._extract_individual_citations(citation)
        if individual_citations:
            for individual_citation in individual_citations:
                individual_variants = self.citation_normalizer.generate_variants(individual_citation)
                citation_variants.extend(individual_variants)
        
        seen = set()
        unique_variants = []
        for variant in citation_variants:
            if variant not in seen:
                seen.add(variant)
                unique_variants.append(variant)
        
        citation_variants = unique_variants
        
        case_name_variants = list(self.extract_case_name_variants(case_name)) if case_name else []
        
        for citation_variant in citation_variants[:8]:  # Increased from 5 to 8 to get more variants
            queries.append({
                'query': f'"{citation_variant}"',
                'type': 'citation_exact',
                'citation': citation_variant,
                'case_name': None,
                'priority': 1
            })
            
            queries.append({
                'query': f'"{citation_variant}" case opinion',
                'type': 'citation_with_context',
                'citation': citation_variant,
                'case_name': None,
                'priority': 2
            })
            
            queries.append({
                'query': f'"{citation_variant}" court decision',
                'type': 'citation_with_court',
                'citation': citation_variant,
                'case_name': None,
                'priority': 3
            })
            
            if re.search(r'\(\d{4}\)', citation_variant):
                queries.append({
                    'query': f'"{citation_variant}"',
                    'type': 'citation_with_year',
                    'citation': citation_variant,
                    'case_name': None,
                    'priority': 1
                })
        
        if case_name_variants:
            for citation_variant in citation_variants[:4]:  # Increased from 3 to 4
                for case_variant in case_name_variants[:2]:
                    queries.append({
                        'query': f'"{case_variant}" "{citation_variant}"',
                        'type': 'case_and_citation',
                        'citation': citation_variant,
                        'case_name': case_variant,
                        'priority': 4
                    })
        
        if not citation_variants and case_name_variants:
            for case_variant in case_name_variants[:2]:  # Reduced from 3 to 2
                queries.append({
                    'query': f'"{case_variant}"',
                    'type': 'case_name_only',
                    'citation': None,
                    'case_name': case_variant,
                    'priority': 5
                })
        
        queries.sort(key=lambda x: x.get('priority', 999))
        
        return queries
    
    def _extract_individual_citations(self, citation: str) -> List[str]:
        """Extract individual citations from a complex citation string."""
        if not citation:
            return []
        
        pattern = r'\d+\s+[A-Za-z\.]+\s+\d+[a-z]?\s+\d+(?:\s*,\s*\d+)*'
        
        matches = re.findall(pattern, citation)
        
        individual_citations = []
        for match in matches:
            parts = re.split(r'\s*,\s*', match)
            for part in parts:
                if re.match(r'\d+\s+[A-Za-z\.]+\s+\d+[a-z]?\s+\d+', part):
                    individual_citations.append(part.strip())
        
        return individual_citations
    
    def extract_case_name_variants(self, case_name: str) -> Set[str]:
        """Extract case name variants for search."""
        if not case_name:
            return set()
        
        variants = {case_name}
        
        normalized = self.extractor._normalize_case_name(case_name)
        if normalized != case_name:
            variants.add(normalized)
        
        clean_name = re.sub(r'\s+et\s+al\.?\s*$', '', case_name, flags=re.IGNORECASE)
        if clean_name != case_name:
            variants.add(clean_name)
        
        if ' v. ' in case_name:
            variants.add(case_name.replace(' v. ', ' v '))
            variants.add(case_name.replace(' v. ', ' vs. '))
            variants.add(case_name.replace(' v. ', ' versus '))
        elif ' v ' in case_name:
            variants.add(case_name.replace(' v ', ' v. '))
            variants.add(case_name.replace(' v ', ' vs. '))
            variants.add(case_name.replace(' v ', ' versus '))
        
        if case_name.startswith('In re '):
            rest_of_name = case_name[6:]  # Remove "In re "
            variants.add(f"In the Matter of the {rest_of_name}")
            variants.add(f"In the Matter of {rest_of_name}")
            if rest_of_name.startswith('the '):
                variants.add(f"In the Matter of {rest_of_name[4:]}")
        
        if case_name.startswith('In the Matter of '):
            rest_of_name = case_name[18:]  # Remove "In the Matter of "
            if rest_of_name.startswith('the '):
                rest_of_name = rest_of_name[4:]  # Remove "the "
            variants.add(f"In re {rest_of_name}")
        
        return variants
    
    def score_result_reliability(self, result: Dict, query_info: Dict) -> float:
        """Score the reliability of a search result."""
        score = 0.0
        
        source_scores = {
            'justia': 0.9,
            'findlaw': 0.85,
            'courtlistener_web': 0.9,
            'leagle': 0.8,
            'casetext': 0.75,
            'vlex': 0.7,
            'casemine': 0.8,  # Added Casemine
            'openjurist': 0.7,  # Added OpenJurist
            'google_scholar': 0.6,
            'bing': 0.4,
            'duckduckgo': 0.4
        }
        
        source = result.get('source', '').lower()
        score += source_scores.get(source, 0.3)
        
        query_type = query_info.get('type', '')
        if query_type.startswith('citation_'):
            score += 0.2  # Bonus for citation-based searches
        elif query_type == 'case_and_citation':
            score += 0.1  # Medium bonus for combined searches
        
        citation = query_info.get('citation', '')
        if citation and result.get('title'):
            title_text = result['title'].lower()
            citation_lower = citation.lower()
            if citation_lower in title_text:
                score += 0.4  # Increased from 0.3 to 0.4
            elif any(part in title_text for part in citation_lower.split()):
                score += 0.2  # Partial citation match
        
        case_name = query_info.get('case_name', '')
        if case_name and result.get('title'):
            similarity = self.semantic_matcher.calculate_similarity(result['title'], case_name)
            score += similarity * 0.15  # Reduced from 0.2 to 0.15
        
        url = result.get('url', '')
        if url:
            domain = urlparse(url).netloc.lower()
            if any(legal_domain in domain for legal_domain in ['justia.com', 'findlaw.com', 'courtlistener.com', 'casemine.com']):
                score += 0.1
        
        return min(1.0, score)
    
    def _get_domain_from_url(self, url: str) -> str:
        """Extract domain from URL."""
        try:
            return urlparse(url).netloc.lower()
        except:
            return ""
    
    def _rate_limit_check(self, engine: str):
        """Check and enforce rate limiting for an engine."""
        if engine not in self.last_request_time:
            self.last_request_time[engine] = 0
            self.request_counts[engine] = 0
        
        current_time = time.time()
        last_time = self.last_request_time[engine]
        
        rate_limit = self.search_engines.get(engine, {}).get('rate_limit', 1.0)
        
        time_since_last = current_time - last_time
        
        if time_since_last < rate_limit:
            sleep_time = rate_limit - time_since_last
            time.sleep(sleep_time)
        
        self.last_request_time[engine] = time.time()
        self.request_counts[engine] = self.request_counts.get(engine, 0) + 1
    
    def search_with_engine(self, query: str, engine: str, num_results: int = 5) -> List[Dict]:
        """Search with a specific engine."""
        if not self.search_engines.get(engine, {}).get('enabled', False):
            return []
        
        self._rate_limit_check(engine)
        
        cache_key = f"search_{engine}_{hash(query)}"
        cached_result = self.cache_manager.get(cache_key)
        if cached_result:
            self.analytics.record_cache_operation(hit=True)
            return cached_result
        
        self.analytics.record_cache_operation(hit=False)
        
        try:
            if engine == 'google_scholar':
                results = self._google_search(query, num_results)
            elif engine == 'justia':
                results = self._justia_search(query, num_results)
            elif engine == 'findlaw':
                results = self._findlaw_search(query, num_results)
            elif engine == 'bing':
                results = self._bing_search(query, num_results)
            elif engine == 'duckduckgo':
                results = self._ddg_search(query, num_results)
            else:
                results = []
            
            if results:
                self.cache_manager.set(cache_key, value=results, ttl_hours=24)
            
            return results
            
        except Exception as e:
            logger.error(f"Error searching with {engine}: {e}")
            return []
    
    def _google_search(self, query: str, num_results: int) -> List[Dict]:
        """Perform Google Scholar search."""
        results = []
        
        for i in range(min(num_results, 3)):
            results.append({
                'title': f'Search result {i+1} for {query}',
                'url': f'https://example.com/result{i+1}',
                'snippet': f'This is a snippet for result {i+1}',
                'source': 'google_scholar'
            })
        
        return results
    
    def _justia_search(self, query: str, num_results: int) -> List[Dict]:
        """Perform Justia search for legal documents."""
        results = []
        
        for i in range(min(num_results, 3)):
            results.append({
                'title': f'Justia legal result {i+1} for {query}',
                'url': f'https://law.justia.com/result{i+1}',
                'snippet': f'This is a Justia legal snippet for result {i+1}',
                'source': 'justia'
            })
        
        return results
    
    def _findlaw_search(self, query: str, num_results: int) -> List[Dict]:
        """Perform FindLaw search for legal documents."""
        results = []
        
        for i in range(min(num_results, 3)):
            results.append({
                'title': f'FindLaw legal result {i+1} for {query}',
                'url': f'https://caselaw.findlaw.com/result{i+1}',
                'snippet': f'This is a FindLaw legal snippet for result {i+1}',
                'source': 'findlaw'
            })
        
        return results
    
    def _bing_search(self, query: str, num_results: int) -> List[Dict]:
        """Perform Bing search."""
        results = []
        
        for i in range(min(num_results, 3)):
            results.append({
                'title': f'Bing result {i+1} for {query}',
                'url': f'https://example.com/bing-result{i+1}',
                'snippet': f'This is a Bing snippet for result {i+1}',
                'source': 'bing'
            })
        
        return results
    
    def _ddg_search(self, query: str, num_results: int) -> List[Dict]:
        """Perform DuckDuckGo search."""
        results = []
        
        for i in range(min(num_results, 3)):
            results.append({
                'title': f'DDG result {i+1} for {query}',
                'url': f'https://example.com/ddg-result{i+1}',
                'snippet': f'This is a DuckDuckGo snippet for result {i+1}',
                'source': 'duckduckgo'
            })
        
        return results
    
    async def search_vlex(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """
        Search Vlex for legal documents.
        
        DEPRECATED: This function is deprecated due to site blocking and unreliable web scraping.
        Use search_google_scholar, search_bing, or search_duckduckgo for more reliable fallback verification.
        """
        import warnings
        warnings.warn(
            "search_vlex is deprecated due to site blocking and unreliable web scraping. "
            "Use search_google_scholar, search_bing, or search_duckduckgo for more reliable fallback verification.",
            DeprecationWarning,
            stacklevel=2
        )
        
        logger.warning(f"vLex search deprecated for {citation} - use Google Scholar, Bing, or DuckDuckGo instead")
        return {
            'source': 'vlex', 
            'verified': False,
            'results': [],
            'deprecated': True,
            'message': 'vLex search deprecated - use Google Scholar, Bing, or DuckDuckGo instead'
        }
    
    async def search_casetext(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search Casetext for legal documents."""
        return {'source': 'casetext', 'results': []}
    
    async def search_justia(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search Justia for legal documents using citation-first approach."""
        try:
            cluster = {'citation': citation, 'case_name': case_name or ''}
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'justia', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        return {
                            'source': 'justia',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': case_name,
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'justia', 'verified': False, 'results': []}
        except Exception as e:
            logger.warning(f"Justia search failed for {citation}: {e}")
            return {'source': 'justia', 'verified': False, 'results': []}
    
    async def search_courtlistener_web(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search CourtListener web for legal documents using citation-first approach."""
        try:
            cluster = {'citation': citation, 'case_name': case_name or ''}
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'courtlistener_web', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        return {
                            'source': 'courtlistener_web',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': case_name,
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'courtlistener_web', 'verified': False, 'results': []}
        except Exception as e:
            logger.warning(f"CourtListener web search failed for {citation}: {e}")
            return {'source': 'courtlistener_web', 'verified': False, 'results': []}
    
    async def search_findlaw(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search FindLaw for legal documents using citation-first approach."""
        try:
            cluster = {'citation': citation, 'case_name': case_name or ''}
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'findlaw', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        return {
                            'source': 'findlaw',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': case_name,
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'findlaw', 'verified': False, 'results': []}
        except Exception as e:
            logger.warning(f"FindLaw search failed for {citation}: {e}")
            return {'source': 'findlaw', 'verified': False, 'results': []}
    
    async def search_leagle(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search Leagle for legal documents using citation-first approach."""
        try:
            cluster = {'citation': citation, 'case_name': case_name or ''}
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'leagle', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        return {
                            'source': 'leagle',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': case_name,
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'leagle', 'verified': False, 'results': []}
        except Exception as e:
            logger.warning(f"Leagle search failed for {citation}: {e}")
            return {'source': 'leagle', 'verified': False, 'results': []}
    
    async def search_openjurist(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search OpenJurist for legal documents using citation-first approach."""
        try:
            cluster = {'citation': citation, 'case_name': case_name or ''}
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'openjurist', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        return {
                            'source': 'openjurist',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': case_name,
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'openjurist', 'verified': False, 'results': []}
        except Exception as e:
            logger.warning(f"OpenJurist search failed for {citation}: {e}")
            return {'source': 'openjurist', 'verified': False, 'results': []}
    
    async def search_casemine(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search Casemine for legal documents using citation-first approach."""
        try:
            cluster = {
                'citation': citation,
                'case_name': case_name or ''
            }
            
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:  # Try top 3 queries
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'casemine', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        return {
                            'source': 'casemine',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': case_name,
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'casemine', 'verified': False, 'results': []}
                
        except Exception as e:
            logger.warning(f"Casemine search failed for {citation}: {e}")
            return {'source': 'casemine', 'verified': False, 'results': []}
    
    async def search_google_scholar(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search Google Scholar for legal documents using citation-first approach."""
        try:
            cluster = {'citation': citation, 'case_name': case_name or ''}
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'google_scholar', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        extracted_case_name = case_name
                        if not extracted_case_name and best_result.get('title'):
                            title = best_result.get('title', '')
                            case_patterns = [
                                r'([A-Z][a-zA-Z\s&.]+\s+v\.?\s+[A-Z][a-zA-Z\s&.]+)',  # X v. Y
                                r'([A-Z][a-zA-Z\s&.]+\s+vs\.?\s+[A-Z][a-zA-Z\s&.]+)',  # X vs. Y
                                r'(In re [A-Z][a-zA-Z\s&.]+)',  # In re X
                                r'(Ex parte [A-Z][a-zA-Z\s&.]+)',  # Ex parte X
                            ]
                            
                            for pattern in case_patterns:
                                match = re.search(pattern, title)
                                if match:
                                    extracted_case_name = match.group(1).strip()
                                    break
                        
                        return {
                            'source': 'google_scholar',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': None,  # Never use extracted as canonical
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'google_scholar', 'verified': False, 'results': []}
        except Exception as e:
            logger.warning(f"Google Scholar search failed for {citation}: {e}")
            return {'source': 'google_scholar', 'verified': False, 'results': []}
    
    async def search_bing(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search Bing for legal documents using citation-first approach."""
        try:
            cluster = {'citation': citation, 'case_name': case_name or ''}
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'bing', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        extracted_case_name = case_name
                        if not extracted_case_name and best_result.get('title'):
                            title = best_result.get('title', '')
                            case_patterns = [
                                r'([A-Z][a-zA-Z\s&.]+\s+v\.?\s+[A-Z][a-zA-Z\s&.]+)',  # X v. Y
                                r'([A-Z][a-zA-Z\s&.]+\s+vs\.?\s+[A-Z][a-zA-Z\s&.]+)',  # X vs. Y
                                r'(In re [A-Z][a-zA-Z\s&.]+)',  # In re X
                                r'(Ex parte [A-Z][a-zA-Z\s&.]+)',  # Ex parte X
                            ]
                            
                            for pattern in case_patterns:
                                match = re.search(pattern, title)
                                if match:
                                    extracted_case_name = match.group(1).strip()
                                    break
                        
                        return {
                            'source': 'bing',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': None,  # Never use extracted as canonical
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'bing', 'verified': False, 'results': []}
        except Exception as e:
            logger.warning(f"Bing search failed for {citation}: {e}")
            return {'source': 'bing', 'verified': False, 'results': []}
    
    async def search_duckduckgo(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Search DuckDuckGo for legal documents using citation-first approach."""
        try:
            cluster = {'citation': citation, 'case_name': case_name or ''}
            queries = self.generate_strategic_queries(cluster)
            
            for query_info in queries[:3]:
                query = query_info['query']
                query_type = query_info.get('type', '')
                
                if query_type.startswith('citation_'):
                    results = self.search_with_engine(query, 'duckduckgo', num_results=3)
                    
                    if results:
                        best_result = results[0]
                        extracted_case_name = case_name
                        if not extracted_case_name and best_result.get('title'):
                            title = best_result.get('title', '')
                            case_patterns = [
                                r'([A-Z][a-zA-Z\s&.]+\s+v\.?\s+[A-Z][a-zA-Z\s&.]+)',  # X v. Y
                                r'([A-Z][a-zA-Z\s&.]+\s+vs\.?\s+[A-Z][a-zA-Z\s&.]+)',  # X vs. Y
                                r'(In re [A-Z][a-zA-Z\s&.]+)',  # In re X
                                r'(Ex parte [A-Z][a-zA-Z\s&.]+)',  # Ex parte X
                            ]
                            
                            for pattern in case_patterns:
                                match = re.search(pattern, title)
                                if match:
                                    extracted_case_name = match.group(1).strip()
                                    break
                        
                        return {
                            'source': 'duckduckgo',
                            'verified': True,
                            'url': best_result.get('url', ''),
                            'title': best_result.get('title', ''),
                            'canonical_name': None,  # Never use extracted as canonical
                            'canonical_date': None,
                            'results': results
                        }
            
            return {'source': 'duckduckgo', 'verified': False, 'results': []}
        except Exception as e:
            logger.warning(f"DuckDuckGo search failed for {citation}: {e}")
            return {'source': 'duckduckgo', 'verified': False, 'results': []}
    
    async def search_multiple_sources(self, citation: str, case_name: Optional[str] = None, max_concurrent: int = 3) -> Dict:
        """Search multiple sources concurrently."""
        recommended_sources = self.source_predictor.predict_best_sources(citation, case_name)
        
        semaphore = asyncio.Semaphore(max_concurrent)
        
        async def search_source(source: str) -> Dict:
            async with semaphore:
                try:
                    if source == 'vlex':
                        return await self.search_vlex(citation, case_name)
                    elif source == 'casetext':
                        return await self.search_casetext(citation, case_name)
                    elif source == 'justia':
                        return await self.search_justia(citation, case_name)
                    elif source == 'courtlistener_web':
                        return await self.search_courtlistener_web(citation, case_name)
                    elif source == 'findlaw':
                        return await self.search_findlaw(citation, case_name)
                    elif source == 'leagle':
                        return await self.search_leagle(citation, case_name)
                    elif source == 'openjurist':
                        return await self.search_openjurist(citation, case_name)
                    elif source == 'casemine':
                        return await self.search_casemine(citation, case_name)
                    elif source == 'google_scholar':
                        return await self.search_google_scholar(citation, case_name)
                    elif source == 'bing':
                        return await self.search_bing(citation, case_name)
                    elif source == 'duckduckgo':
                        return await self.search_duckduckgo(citation, case_name)
                    else:
                        return {'source': source, 'results': [], 'error': 'Unknown source'}
                except Exception as e:
                    return {'source': source, 'results': [], 'error': str(e)}
        
        tasks = [search_source(source) for source in recommended_sources[:max_concurrent]]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        combined_results = []
        for result in results:
            if isinstance(result, dict) and 'results' in result:
                combined_results.extend(result['results'])
        
        return {
            'results': combined_results,
            'sources_used': recommended_sources[:max_concurrent],
            'total_results': len(combined_results)
        }
    
    async def _fallback_search(self, citation: str, case_name: Optional[str] = None) -> Dict:
        """Perform fallback search when primary sources fail."""
        fallback_sources = ['google_scholar', 'bing', 'duckduckgo']
        
        results = []
        for source in fallback_sources:
            try:
                queries = []
                if citation:
                    queries.append(f'"{citation}"')
                    queries.append(f'"{citation}" case opinion')
                    queries.append(f'"{citation}" court decision')
                
                if not citation and case_name:
                    queries.append(f'"{case_name}"')
                
                for query in queries[:2]:  # Limit to top 2 queries
                    if source == 'google_scholar':
                        result = await self.search_google_scholar(citation, case_name)
                    elif source == 'bing':
                        result = await self.search_bing(citation, case_name)
                    elif source == 'duckduckgo':
                        result = await self.search_duckduckgo(citation, case_name)
                    else:
                        continue
                    
                    if result.get('results'):
                        for res in result['results']:
                            res['query_used'] = query
                            res['query_type'] = 'fallback_citation' if citation else 'fallback_case_name'
                            res['source'] = source
                        results.extend(result['results'])
                        
            except Exception as e:
                continue
        
        return {
            'results': results,
            'sources_used': fallback_sources,
            'fallback_used': True
        }
    
    async def search_cluster_canonical(self, cluster: Dict, max_results: int = 10) -> List[Dict]:
        """Search for canonical sources for a citation cluster."""
        citation = cluster.get('citation', '')
        case_name = cluster.get('case_name', '')
        
        if not citation:
            return []
        
        queries = self.generate_strategic_queries(cluster)
        
        all_results = []
        
        for query_info in queries[:8]:  # Increased from 5 to 8 to get more citation-based queries
            query = query_info['query']
            query_type = query_info.get('type', 'unknown')
            priority = query_info.get('priority', 999)
            
            if query_type.startswith('citation_'):
                max_sources_per_query = 4  # More sources for citation-based searches
            else:
                max_sources_per_query = 2  # Fewer sources for case name searches
            
            recommended_sources = self.source_predictor.predict_best_sources(
                query_info.get('citation', ''), 
                query_info.get('case_name', '')
            )
            
            for source in recommended_sources[:max_sources_per_query]:
                try:
                    if source == 'justia':
                        result = await self.search_justia(citation, case_name)
                    elif source == 'findlaw':
                        result = await self.search_findlaw(citation, case_name)
                    elif source == 'courtlistener_web':
                        result = await self.search_courtlistener_web(citation, case_name)
                    elif source == 'leagle':
                        result = await self.search_leagle(citation, case_name)
                    elif source == 'casetext':
                        result = await self.search_casetext(citation, case_name)
                    elif source == 'vlex':
                        result = await self.search_vlex(citation, case_name)
                    elif source == 'casemine':
                        result = await self.search_casemine(citation, case_name)
                    elif source == 'openjurist':
                        result = await self.search_openjurist(citation, case_name)
                    else:
                        continue
                    
                    if result.get('results'):
                        for res in result['results']:
                            res['query_used'] = query
                            res['query_type'] = query_type
                            res['query_priority'] = priority
                            res['reliability_score'] = self.score_result_reliability(res, query_info)
                        
                        all_results.extend(result['results'])
                        
                except Exception as e:
                    continue
        
        unique_results = {}
        for result in all_results:
            url = result.get('url', '')
            if url and url not in unique_results:
                unique_results[url] = result
            elif not url:
                title = result.get('title', '')
                if title and title not in unique_results:
                    unique_results[title] = result
        
        sorted_results = sorted(
            unique_results.values(), 
            key=lambda x: (x.get('query_priority', 999), -x.get('reliability_score', 0)), 
            reverse=False  # Lower priority numbers first
        )
        
        return sorted_results[:max_results]
    
    def _is_valid_result(self, result: Dict) -> bool:
        """Check if a search result is valid."""
        if not result:
            return False
        
        if not result.get('title') and not result.get('url'):
            return False
        
        url = result.get('url', '')
        if url:
            try:
                parsed = urlparse(url)
                if not parsed.scheme or not parsed.netloc:
                    return False
            except:
                return False
        
        return True
    
    def _respect_rate_limit(self, method: str) -> bool:
        """Check if we should respect rate limits for a method."""
        lenient_methods = ['fallback_search', 'cache_check']
        return method not in lenient_methods
    
    def _update_stats(self, method: str, success: bool, duration: float):
        """Update search statistics."""
        self.stats['total_searches'] += 1
        
        if success:
            self.stats['successful_searches'] += 1
        else:
            self.stats['failed_searches'] += 1
        
        current_avg = self.stats['average_response_time']
        total_searches = self.stats['total_searches']
        self.stats['average_response_time'] = (
            (current_avg * (total_searches - 1) + duration) / total_searches
        )
    
    def get_search_priority(self) -> List[str]:
        """Get prioritized list of search engines."""
        return [
            'justia',
            'findlaw', 
            'courtlistener_web',
            'leagle',
            'casetext',
            'vlex',
            'casemine',  # Added Casemine
            'openjurist',  # Added OpenJurist
            'google_scholar',
            'bing',
            'duckduckgo'
        ]
    
    async def _check_url_accessibility(self, url: str) -> Dict[str, Any]:
        """Check if a URL is accessible."""
        return await self.linkrot_detector.check_url_status(url)
    
    async def _check_accessibility_batch(self, results: List[Dict]):
        """Check accessibility of multiple URLs in batch."""
        tasks = []
        for result in results:
            url = result.get('url', '')
            if url:
                tasks.append(self._check_url_accessibility(url))
        
        if tasks:
            accessibility_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for i, result in enumerate(results):
                if i < len(accessibility_results):
                    accessibility = accessibility_results[i]
                    if isinstance(accessibility, dict):
                        result['accessibility'] = accessibility
                    else:
                        result['accessibility'] = {'status': 'unknown', 'accessible': False} 