"""
Vue API Endpoints Blueprint
Main API routes for the CaseStrainer application
"""

import osfrom src.config import DEFAULT_REQUEST_TIMEOUT, COURTLISTENER_TIMEOUT, CASEMINE_TIMEOUT, WEBSEARCH_TIMEOUT, SCRAPINGBEE_TIMEOUT

import sys
import uuid
import logging
import traceback
import time
import json
from datetime import datetime
from flask import Blueprint, request, jsonify, current_app, g, Response
from werkzeug.utils import secure_filename

project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from src.api.services.citation_service import CitationService

logger = logging.getLogger(__name__)

vue_api = Blueprint('vue_api', __name__)

citation_service = CitationService()


@vue_api.route('/health', methods=['GET'])
@vue_api.route('/health_check', methods=['GET'])
def health_check():
    """Health check endpoint for Docker health monitoring and external access."""
    try:
        health_status = {
            'status': 'healthy',
            'message': 'Vue API is running',
            'timestamp': datetime.utcnow().isoformat(),
            'service': 'CaseStrainer Backend',
            'version': '1.0.0',
            'checks': {}
        }
        
        try:
            import redis
            redis_url = os.environ.get('REDIS_URL', 'redis://localhost:6379/0')
            r = redis.from_url(redis_url)
            r.ping()
            health_status['checks']['redis'] = 'healthy'
        except Exception as e:
            health_status['checks']['redis'] = f'unhealthy: {str(e)}'
            health_status['status'] = 'degraded'
        
        critical_dirs = ['./src', './data', './logs', './uploads']
        for dir_path in critical_dirs:
            if os.path.exists(dir_path):
                health_status['checks'][f'directory_{dir_path}'] = 'healthy'
            else:
                health_status['checks'][f'directory_{dir_path}'] = 'unhealthy'
                health_status['status'] = 'degraded'
        
        if health_status['status'] == 'healthy':
            return jsonify(health_status), 200
        elif health_status['status'] == 'degraded':
            return jsonify(health_status), 200  # Still 200 but status shows degraded
        else:
            return jsonify(health_status), 500
            
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }), 500


@vue_api.route('/analyze', methods=['POST'])
def analyze_text():
    """
    Analyze text for citations.
    
    Expected JSON payload:
    {
        "text": "text to analyze",
        "type": "text"
    }
    
    Or form data with:
    - text: text to analyze
    - type: "text"
    
    Returns:
        JSON response with citation analysis results
    """
    request_id = str(uuid.uuid4())
    logger.info(f"[Request {request_id}] ===== Starting analyze request =====")
    logger.info(f"[Request {request_id}] Method: {request.method}")
    logger.info(f"[Request {request_id}] Content-Type: {request.content_type}")
    
    try:
        data = None
        if request.content_type and 'application/json' in request.content_type:
            logger.info(f"[Request {request_id}] Attempting to parse JSON data")
            try:
                data = request.get_json()
                logger.info(f"[Request {request_id}] JSON parsing successful: {data}")
            except Exception as e:
                logger.error(f"[Request {request_id}] JSON parsing failed: {str(e)}")
                return jsonify({
                    'error': 'Invalid JSON data',
                    'request_id': request_id,
                    'details': str(e)
                }), 400
        else:
            text_content = request.form.get('text', '')
            url_content = request.form.get('url', '')
            if text_content is None:
                text_content = ''
            if url_content is None:
                url_content = ''
            
            data = {
                'text': text_content,
                'url': url_content,
                'type': request.form.get('type', 'text')
            }
        
        if not data or 'text' not in data or not data['text']:
            return jsonify({
                'error': 'Missing or invalid request data',
                'request_id': request_id,
                'content_type': request.content_type
            }), 400
            
        text_length = len(data['text']) if data['text'] else 0
        logger.info(f"[Request {request_id}] Starting analysis of text (length: {text_length})")
        
        try:
            from src.enhanced_sync_processor import EnhancedSyncProcessor, ProcessingOptions
            import time
            
            options = ProcessingOptions(
                enable_async_verification=True,
                enable_enhanced_verification=True,
                enable_confidence_scoring=True,
                courtlistener_api_key=os.getenv('COURTLISTENER_API_KEY')
            )
            
            processor = EnhancedSyncProcessor(options)
            
            start_time = time.time()
            result = processor.process_any_input_enhanced(
                input_data=data['text'],
                input_type='text',
                options={
                    'document_type': 'legal_brief',
                    'enable_enhanced_verification': True,
                    'enable_async_verification': True,
                    'enable_clustering': True,
                    'request_id': request_id
                }
            )
            process_time = time.time() - start_time
            
            if not isinstance(result, dict):
                result = {}
            result['request_id'] = request_id
            result['processing_time'] = process_time
            
            try:
                from src.data_separation_validator import validate_data_separation
                
                citations = result.get('citations', [])
                if citations:
                    separation_report = validate_data_separation(citations)
                    if not separation_report['is_valid']:
                        logger.warning(f"[Request {request_id}] Data separation issues detected:")
                        for warning in separation_report['warnings']:
                            logger.warning(f"  â€¢ {warning}")
                        
                        result['data_separation_validation'] = {
                            'contamination_detected': True,
                            'contamination_rate': separation_report['contamination_rate'],
                            'separation_health': separation_report['separation_health']
                        }
                    else:
                        logger.info(f"[Request {request_id}] Data separation validation passed")
            except Exception as e:
                logger.warning(f"[Request {request_id}] Data separation validation failed: {e}")
            
            restructured_result = {
                'result': result,
                'request_id': request_id,
                'processing_time_ms': int(process_time * 1000),
                'document_length': len(data['text'])
            }
            
            logger.info(f"[Request {request_id}] Request completed successfully in {0}ms")
            return jsonify(restructured_result)
            
        except Exception as e:
            error_msg = f"[Request {request_id}] Exception in text processing: {str(e)}"
            logger.error(error_msg, exc_info=True)
            return jsonify({
                'error': 'Failed to process text',
                'request_id': request_id,
                'details': str(e) if current_app.debug else None
            }), 500
            
    except Exception as e:
        logger.error(
            f"[Request {request_id}] Unexpected error in /analyze endpoint: {str(e)}\n{traceback.format_exc()}"
        )
        return jsonify({
            'error': 'An unexpected error occurred',
            'details': str(e) if current_app.debug else None,
            'request_id': request_id,
            'content_type': request.content_type
        }), 500


@vue_api.route('/task_status/<task_id>', methods=['GET'])
def get_task_status(task_id):
    """
    Get the status and results of an async task.
    
    Args:
        task_id: The task ID to check
        
    Returns:
        JSON response with task status and results if completed
    """
    logger.info(f"[Request {task_id}] Checking task status")
    
    try:
        from rq import Queue
        from redis import Redis
        
        redis_url = os.environ.get('REDIS_URL', 'redis://:caseStrainerRedis123@casestrainer-redis-prod:6379/0')
        redis_conn = Redis.from_url(redis_url)
        queue = Queue('casestrainer', connection=redis_conn)
        
        job = queue.fetch_job(task_id)
        
        if not job:
            return jsonify({
                'error': 'Task not found',
                'task_id': task_id
            }), 404
        
        if job.is_finished:
            result = job.result
            logger.info(f"[Request {task_id}] Task completed successfully")
            return jsonify({
                'task_id': task_id,
                'status': 'completed',
                'result': result
            })
        elif job.is_failed:
            logger.error(f"[Request {task_id}] Task failed: {job.exc_info}")
            return jsonify({
                'task_id': task_id,
                'status': 'failed',
                'error': str(job.exc_info) if job.exc_info else 'Unknown error'
            }), 500
        else:
            logger.info(f"[Request {task_id}] Task still processing")
            return jsonify({
                'task_id': task_id,
                'status': 'processing',
                'message': 'Task is still being processed'
            })
            
    except Exception as e:
        logger.error(f"[Request {task_id}] Exception checking task status: {str(e)}", exc_info=True)
        return jsonify({
            'error': 'Failed to check task status',
            'task_id': task_id,
            'details': str(e) if current_app.debug else None
        }), 500


@vue_api.route('/analyze/verification-status/<request_id>', methods=['GET'])
def get_verification_status(request_id):
    """
    Get the verification status for a request.
    
    Args:
        request_id: The request ID to check
        
    Returns:
        JSON response with verification status
    """
    logger.info(f"[Request {request_id}] Checking verification status")
    
    try:
        from verification_manager import VerificationManager
        
        verification_manager = VerificationManager()
        
        status = verification_manager.get_verification_status(request_id)
        
        if status:
            return jsonify(status)
        else:
            return jsonify({
                'error': 'Verification not found',
                'request_id': request_id
            }), 404
            
    except Exception as e:
        logger.error(f"[Request {request_id}] Exception checking verification status: {str(e)}", exc_info=True)
        return jsonify({
            'error': 'Failed to check verification status',
            'request_id': request_id,
            'details': str(e) if current_app.debug else None
        }), 500


@vue_api.route('/analyze/verification-results/<request_id>', methods=['GET'])
def get_verification_results(request_id):
    """
    Get the verification results for a completed request.
    
    Args:
        request_id: The request ID to get results for
        
    Returns:
        JSON response with verification results
    """
    logger.info(f"[Request {request_id}] Getting verification results")
    
    try:
        from verification_manager import VerificationManager
        
        verification_manager = VerificationManager()
        
        results = verification_manager.get_verification_results(request_id)
        
        if results:
            return jsonify(results)
        else:
            return jsonify({
                'error': 'Verification results not found or not completed',
                'request_id': request_id
            }), 404
            
    except Exception as e:
        logger.error(f"[Request {request_id}] Exception getting verification results: {str(e)}", exc_info=True)
        return jsonify({
            'error': 'Failed to get verification results',
            'request_id': request_id,
            'details': str(e) if current_app.debug else None
        }), 500


@vue_api.route('/analyze/verification-stream/<request_id>', methods=['GET'])
def verification_stream(request_id):
    """
    Server-Sent Events stream for real-time verification updates.
    
    Args:
        request_id: The request ID to stream updates for
        
    Returns:
        SSE stream of verification updates
    """
    logger.info(f"[Request {request_id}] Starting verification stream")
    
    def generate_verification_events():
        """Generator for SSE verification events"""
        try:
            from verification_manager import VerificationManager
            
            verification_manager = VerificationManager()
            
            yield f"data: {json.dumps({'type': 'status', 'request_id': request_id, 'message': 'Starting verification stream'})}\n\n"
            
            last_status = None
            max_wait_time = 300  # 5 minutes timeout
            waited_time = 0
            
            while waited_time < max_wait_time:
                try:
                    status = verification_manager.get_verification_status(request_id)
                    
                    if status and status != last_status:
                        yield f"data: {json.dumps({'type': 'status_update', 'request_id': request_id, 'status': status})}\n\n"
                        last_status = status
                        
                        if status.get('status') == 'completed':
                            results = verification_manager.get_verification_results(request_id)
                            if results:
                                yield f"data: {json.dumps({'type': 'verification_complete', 'request_id': request_id, 'results': results})}\n\n"
                            break
                        elif status.get('status') == 'failed':
                            yield f"data: {json.dumps({'type': 'verification_failed', 'request_id': request_id, 'error': status.get('error_message', 'Unknown error')})}\n\n"
                            break
                    
                    time.sleep(1)
                    waited_time += 1
                    
                except Exception as e:
                    logger.error(f"Error in verification stream for {request_id}: {e}")
                    yield f"data: {json.dumps({'type': 'error', 'request_id': request_id, 'error': str(e)})}\n\n"
                    break
            
            yield f"data: {json.dumps({'type': 'stream_complete', 'request_id': request_id})}\n\n"
            
        except Exception as e:
            logger.error(f"Error generating verification events for {request_id}: {e}")
            yield f"data: {json.dumps({'type': 'error', 'request_id': request_id, 'error': str(e)})}\n\n"
    
    return Response(
        generate_verification_events(),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Cache-Control'
        }
    )


if __name__ == '__main__':
    pass


