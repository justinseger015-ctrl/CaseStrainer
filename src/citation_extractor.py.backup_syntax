"""
Citation Extractor

This module contains core citation extraction logic using both regex-based
and eyecite-based approaches.
"""

import refrom src.config import DEFAULT_REQUEST_TIMEOUT, COURTLISTENER_TIMEOUT, CASEMINE_TIMEOUT, WEBSEARCH_TIMEOUT, SCRAPINGBEE_TIMEOUT

import logging
from typing import List, Dict, Any, Optional
from src.models import CitationResult
from src.citation_types import CitationMatch, CitationList, CitationDict
from src.citation_utils import (
    normalize_citation, extract_citation_components, 
    extract_context, is_valid_case_name
)

logger = logging.getLogger(__name__)

try:
    import eyecite
    from eyecite import get_citations
    from eyecite.tokenizers import AhocorasickTokenizer
    EYECITE_AVAILABLE = True
    logger.info("Eyecite successfully imported")
except ImportError as e:
    EYECITE_AVAILABLE = False
    logger.warning(f"Eyecite not available - install with: pip install eyecite. Error: {e}")
except Exception as e:
    EYECITE_AVAILABLE = False
    logger.warning(f"Eyecite import failed with unexpected error: {e}")

class CitationExtractor:
    """Core citation extraction functionality."""
    
    def __init__(self):
        self._init_patterns()
        self._init_case_name_patterns()
        self._init_citation_block_patterns()
    
    def _init_patterns(self):
        """Initialize citation patterns."""
        self.citation_patterns = [
            r'\b\d+\s+U\.S\.\s+\d+\b',
            r'\b\d+\s+S\.Ct\.\s+\d+\b',
            r'\b\d+\s+F\.\d*d?\b',
            r'\b\d+\s+F\.Supp\.\d*d?\b',
            r'\b\d+\s+F\.App\'x\b',
            
            r'\b\d+\s+Wn\.\s*3d\s*\n?\s*\d+\b',  # Washington Reports, 3d Series (e.g., 2 Wn. 3d 329)
            r'\b\d+\s+Wn\.\s*2d\s*\n?\s*\d+\b',  # Washington Reports, 2d Series (e.g., 169 Wn.2d 815)
            r'\b\d+\s+Wn\.\s*App\.\s*\d+\b',  # Washington Court of Appeals
            r'\b\d+\s+Wn\.\s*\d+\b',  # Washington Reports
            r'\b\d+\s+Wash\.\s*3d\s*\n?\s*\d+\b',  # Washington Reports, 3d Series (alternate format)
            r'\b\d+\s+Wash\.\s*2d\s*\n?\s*\d+\b',  # Washington Reports, 2d Series (alternate format)
            r'\b\d+\s+P\.(?:\s*\d*d?\s+\d+\b|\s*\d+\.\d+\b)',  # Pacific Reporter (with or without series)
            r'\b\d+\s+N\.W\.(?:\s*\d*d?\s+\d+\b|\s*\d+\.\d+\b)',  # North Western Reporter
            r'\b\d+\s+S\.W\.(?:\s*\d*d?\s+\d+\b|\s*\d+\.\d+\b)',  # South Western Reporter
            r'\b\d+\s+N\.E\.(?:\s*\d*d?\s+\d+\b|\s*\d+\.\d+\b)',  # North Eastern Reporter
            r'\b\d+\s+S\.E\.(?:\s*\d*d?\s+\d+\b|\s*\d+\.\d+\b)',  # South Eastern Reporter
            r'\b\d+\s+A\.(?:\s*\d*d?\s+\d+\b|\s*\d+\.\d+\b)',  # Atlantic Reporter
            r'\b\d+\s+So\.(?:\s*\d*d?\s+\d+\b|\s*\d+\.\d+\b)',  # Southern Reporter
            r'\b\d+\s+Cal\.(?:\s*\d*d?\s+\d+\b|\s*\d+\.\d+\b)'  # California Reporter
            
            r'\b\d+\s+WL\s+\d+\b',
            r'\b\d{4}\s+LEXIS\s+\d+\b',
        ]
        
        self.compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in self.citation_patterns]
    
    def _init_case_name_patterns(self):
        """Initialize case name extraction patterns."""
        self.case_name_patterns = [
            r'(State(?:\s+of\s+[A-Z][a-z]+)?)\s+v\.\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)',
            
            r'In\s+re\s+([A-Z][a-zA-Z\s&.,\'-]+)',
            r'In\s+re\s+the\s+([A-Z][a-zA-Z\s&.,\'-]+)',
            
            r'([A-Z][a-zA-Z&.\'-]+(?:\s+[A-Z][a-zA-Z&.\'-]+)*)\s+v\.\s+([A-Z][a-zA-Z&.\'-]+(?:\s+[A-Z][a-zA-Z&.\'-]+)*)',
            r'([A-Z][a-zA-Z&.\'-]+(?:\s+[A-Z][a-zA-Z&.\'-]+)*)\s+vs\.\s+([A-Z][a-zA-Z&.\'-]+(?:\s+[A-Z][a-zA-Z&.\'-]+)*)',
            r'([A-Z][a-zA-Z&.\'-]+(?:\s+[A-Z][a-zA-Z&.\'-]+)*)\s+versus\s+([A-Z][a-zA-Z&.\'-]+(?:\s+[A-Z][a-zA-Z&.\'-]+)*)',
            
            r'([A-Z][a-zA-Z&.\'-]+(?:\s+[A-Z][a-zA-Z&.\'-]+)*)\s+&\s+([A-Z][a-zA-Z&.\'-]+(?:\s+[A-Z][a-zA-Z&.\'-]+)*)'
        ]
        
        self.compiled_case_patterns = [re.compile(pattern) for pattern in self.case_name_patterns]
    
    def _init_citation_block_patterns(self):
        """Initialize patterns for identifying the start of a citation block."""
        self.citation_block_patterns = [
            r'\b\d+\s+U\.S\.\s+\d+\b',
            r'\b\d+\s+S\.Ct\.\s+\d+\b',
            r'\b\d+\s+F\.\d*d?\b',
            r'\b\d+\s+F\.Supp\.\d*d?\b',
            r'\b\d+\s+F\.App\'x\b',
            r'\b\d+\s+P\.\d*d?\s+\d+\b',
            r'\b\d+\s+N\.W\.\d*d?\s+\d+\b',
            r'\b\d+\s+S\.W\.\d*d?\s+\d+\b',
            r'\b\d+\s+N\.E\.\d*d?\s+\d+\b',
            r'\b\d+\s+S\.E\.\d*d?\s+\d+\b',
            r'\b\d+\s+A\.\d*d?\s+\d+\b',
            r'\b\d+\s+So\.\d*d?\s+\d+\b',
            r'\b\d+\s+Cal\.\d*d?\s+\d+\b',
            r'\b\d+\s+Wash\.\d*d?\s+\d+\b',
            r'\b\d+\s+Wn\.\s*3d\s*\n?\s*\d+\b',  # Washington Reports, 3d Series
            r'\b\d+\s+Wn\.\s*2d\s*\n?\s*\d+\b',  # Washington Reports, 2d Series
            r'\b\d+\s+Wn\.\s*\d*d?\s+\d+\b',  # Fixed: allows optional space between Wn. and volume
            r'\b\d+\s+Wn\.\s*App\.\s*\d+\b',  # Washington Court of Appeals
            r'\b\d+\s+WL\s+\d+\b',
            r'\b\d{4}\s+LEXIS\s+\d+\b',
        ]
        self.compiled_citation_block_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in self.citation_block_patterns]
    
    def _extract_citation_blocks(self, text: str) -> CitationList:
        """
        Extract complete citation blocks: case name + all parallel citations + year.
        This handles cases like "DeSean v. Sanger, 2 Wn. 3d 329, 334-35, 536 P.3d 191 (2023)"
        """
        if not text:
            return []
        
        logger.info(f"üîç [CITATION_BLOCKS] Starting citation block extraction for text: '{text[:200]}...'")
        citations = []
        
        citation_block_pattern = re.compile(
            r'([A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*\s+v\.\s+[A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*|'  # Enhanced v. pattern - REQUIRES subsequent words to be capitalized
            r'State(?:\s+of\s+[A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*)??\s+v\.\s+[A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*|'  # Enhanced State v. pattern
            r'In\s+re\s+[A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*)'  # Enhanced In re pattern
            r'[,\s]*'  # Optional comma and whitespace after case name
            r'([^()]+)'  # All citations and content between case name and year
            r'\((\d{4})\)'  # Year in parentheses
        )
        
        matches = list(citation_block_pattern.finditer(text))
        logger.info(f"üîç [CITATION_BLOCKS] Pattern found {len(matches)} matches")
        for i, match in enumerate(matches):
            logger.info(f"üîç [CITATION_BLOCKS] Match {i+1}: '{match.group(0)}'")
        
        for match in citation_block_pattern.finditer(text):
            case_name = match.group(1).strip().rstrip(',')  # Remove trailing comma
            
            contamination_phrases = [
                r'\b(de\s+novo)\b', r'\b(questions?\s+of\s+law)\b', r'\b(statutory\s+interpretation)\b',
                r'\b(in\s+light\s+of)\b', r'\b(the\s+record\s+certified)\b', r'\b(federal\s+court)\b',
                r'\b(this\s+court\s+reviews?)\b', r'\b(we\s+review)\b', r'\b(certified\s+questions?)\b',
                r'\b(issue\s+of\s+law)\b', r'\b(also\s+an?\s+issue)\b', r'\b(are\s+that)\b', r'\b(and\s+by)\b',
                r'\b(is\s+also)\b', r'\b(an\s+issue)\b'
            ]
            
            for phrase_pattern in contamination_phrases:
                case_name = re.sub(phrase_pattern, '', case_name, flags=re.IGNORECASE)
            
            case_name_clean_patterns = [
                r'([A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*)\s+v\.\s+([A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*)',
                r'(State(?:\s+of\s+[A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*)?\s+v\.\s+([A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*)',
                r'(In\s+re\s+[A-Z][a-zA-Z\'\.\&]*(?:\s+(?:[A-Z][a-zA-Z\'\.\&]*|of|the|and|&))*)'
            ]
            
            cleaned_name = None
            for clean_pattern in case_name_clean_patterns:
                clean_match = re.search(clean_pattern, case_name)
                if clean_match:
                    if len(clean_match.groups()) >= 2:
                        cleaned_name = f"{clean_match.group(1).strip()} v. {clean_match.group(2).strip()}"
                    else:
                        cleaned_name = clean_match.group(1).strip()
                    break
            
            if cleaned_name:
                case_name = cleaned_name
            
            case_name = re.sub(r'\s+', ' ', case_name).strip()
            case_name = re.sub(r'^[.\s,;:]+', '', case_name)
            case_name = re.sub(r'^(the|a|an)\s+', '', case_name, flags=re.IGNORECASE)
            
            citations_text = match.group(2).strip()
            year = match.group(3)
            start, end = match.span()
            
            logger.info(f"üîç Found citation block: '{case_name}' with citations '{citations_text}' year {year}")
            
            individual_citations = self._extract_citations_from_block(citations_text)
            
            for citation_text in individual_citations:
                citation_start = text.find(citation_text, start)
                citation_end = citation_start + len(citation_text) if citation_start != -1 else start
                
                citation = CitationResult(
                    citation=citation_text,
                    start_index=citation_start,
                    end_index=citation_end,
                    extracted_case_name=case_name,
                    extracted_date=year,
                    canonical_name=None,
                    canonical_date=None,
                    url=None,
                    verified=False,
                    source="citation_block",
                    confidence=0.9,  # Higher confidence for block extraction
                    metadata={
                        'block_case_name': case_name,
                        'block_year': year,
                        'parallel_citations': individual_citations
                    }
                )
                
                
                citations.append(citation)
        
        return citations
    
    def _extract_citations_from_block(self, citations_text: str) -> List[str]:
        """Extract individual citations from a citation block text."""
        citations = []
        
        parts = [part.strip() for part in citations_text.split(',')]
        
        for part in parts:
            if not part or len(part) < 5:  # Skip very short parts
                continue
            
            for pattern in self.compiled_patterns:
                if pattern.search(part):
                    citations.append(part)
                    break
        
        return citations
    

    
    def extract_with_regex(self, text: str) -> CitationList:
        """Extract citations using regex patterns."""
        if not text:
            return []
        
        citation_blocks = self._extract_citation_blocks(text)
        if citation_blocks:
            logger.info(f"üîç Extracted {len(citation_blocks)} citation blocks")
            return citation_blocks
        
        citations = []
        
        for pattern in self.compiled_patterns:
            for match in pattern.finditer(text):
                citation_text = match.group(0)
                start, end = match.span()
                
                logger.info(f"üîç Extracted citation: '{citation_text}' at position {start}-{end}")
                
                citation = CitationResult(
                    citation=citation_text,
                    start_index=start,
                    end_index=end,
                    extracted_case_name=None,
                    extracted_date=None,
                    canonical_name=None,
                    canonical_date=None,
                    url=None,
                    verified=False,
                    source="regex",
                    confidence=0.7,
                    metadata={}
                )
                
                case_name = self._extract_case_name_proximity_based(text, start, end, citation_text)
                
                if case_name:
                    citation.extracted_case_name = case_name
                
                citation_year = self._extract_year_from_citation(citation_text, text, start)
                if citation_year:
                    citation.extracted_date = citation_year
                
                citations.append(citation)
        
        return citations
    
    def extract_with_eyecite(self, text: str) -> CitationList:
        """Extract citations using eyecite library."""
        if not EYECITE_AVAILABLE or not text:
            return []
        
        try:
            citations = []
            eyecite_results = get_citations(text)
            
            for citation_obj in eyecite_results:
                citation_text = self._extract_citation_text_from_eyecite(citation_obj)
                if not citation_text:
                    continue
                
                start_pos = getattr(citation_obj, 'start', None)
                end_pos = getattr(citation_obj, 'end', None)
                
                citation = CitationResult(
                    citation=citation_text,
                    start_index=start_pos,
                    end_index=end_pos,
                    extracted_case_name=None,
                    extracted_date=None,
                    canonical_name=None,
                    canonical_date=None,
                    url=None,
                    verified=False,
                    source="eyecite",
                    confidence=0.8,
                    metadata={}
                )
                
                self._extract_eyecite_metadata(citation, citation_obj)
                
                citations.append(citation)
            
            return citations
            
        except Exception as e:
            logger.error(f"Error extracting citations with eyecite: {e}")
            return []
    
    def _extract_citation_text_from_eyecite(self, citation_obj) -> Optional[str]:
        """Extract citation text from eyecite citation object."""
        try:
            if hasattr(citation_obj, 'citation'):
                return str(citation_obj.citation)
            elif hasattr(citation_obj, 'groups'):
                return ' '.join(str(g) for g in citation_obj.groups if g)
            else:
                return str(citation_obj)
        except Exception as e:
            logger.error(f"Error extracting citation text from eyecite object: {e}")
            return None
    
    def _extract_eyecite_metadata(self, citation: CitationResult, citation_obj):
        """Extract metadata from eyecite citation object."""
        try:
            if hasattr(citation_obj, 'case_name'):
                citation.extracted_case_name = str(citation_obj.case_name)
            
            if hasattr(citation_obj, 'year'):
                citation.extracted_date = str(citation_obj.year)
            
            if citation.metadata is None:
                citation.metadata = {}
            citation.metadata['eyecite_type'] = type(citation_obj).__name__
            
        except Exception as e:
            logger.error(f"Error extracting eyecite metadata: {e}")
    
    def _extract_case_name_proximity_based(self, text: str, start: int, end: int, citation_text: str) -> Optional[str]:
        """Extract case name using proximity-based approach with smaller context windows."""
        if not text or start is None:
            return None
        
        context_start = max(0, start - 200)
        context_end = min(len(text), end + 50)
        context = text[context_start:context_end]
        
        best_match = None
        best_distance = float('inf')
        
        for i, pattern in enumerate(self.compiled_case_patterns):
            for match in pattern.finditer(context):
                if i == 0:  # State v. pattern (first pattern)
                    case_name = f"{match.group(1)} v. {match.group(2)}"
                elif i < 3:  # In re patterns (patterns 1 and 2)
                    case_name = f"In re {match.group(1)}"
                else:  # Standard v. patterns (remaining patterns)
                    case_name = f"{match.group(1)} v. {match.group(2)}"
                
                match_pos = match.start()
                citation_pos = start - context_start
                distance = abs(match_pos - citation_pos)
                
                if distance < best_distance and is_valid_case_name(case_name):
                    best_match = case_name
                    best_distance = distance
        
        if best_match:
            logger.info(f"üîç Found case name: '{best_match}' (distance: {best_distance})")
            return best_match
        
        return None
    
    def _extract_case_name_from_context(self, context: str) -> Optional[str]:
        """Extract case name from context around citation."""
        if not context:
            return None
        
        for i, pattern in enumerate(self.compiled_case_patterns):
            match = pattern.search(context)
            if match:
                if i == 0:  # State v. pattern (first pattern)
                    case_name = f"{match.group(1)} v. {match.group(2)}"
                elif i < 3:  # In re patterns (patterns 1 and 2)
                    case_name = f"In re {match.group(1)}"
                else:  # Standard v. patterns (remaining patterns)
                    case_name = f"{match.group(1)} v. {match.group(2)}"
                
                logger.info(f"üîç Found case name pattern {i}: '{case_name}' from match: {match.groups()}")
                if is_valid_case_name(case_name):
                    logger.info(f"‚úÖ Valid case name: '{case_name}'")
                    return case_name
                else:
                    logger.info(f"‚ùå Invalid case name: '{case_name}'")
        
        return None
    

    
    def _extract_year_from_citation(self, citation_text: str, text: str, start_index: int) -> Optional[str]:
        """Enhanced year extraction with multiple strategies."""
        if not citation_text:
            return None
        
        
        year_match = re.search(r'\((\d{4})\)$', citation_text)
        if year_match:
            return year_match.group(1)
        
        year_match = re.search(r'\b(19|20)\d{2}\b', citation_text)
        if year_match:
            return year_match.group(0)
        
        after_text = text[start_index:start_index + 300]
        year_match = re.search(r'\((\d{4})\)', after_text)
        if year_match:
            return year_match.group(1)
        
        before_text = text[max(0, start_index - 100):start_index]
        year_match = re.search(r'\((\d{4})\)', before_text)
        if year_match:
            return year_match.group(1)
        
        return None
    
    def extract_citations(self, text: str, use_eyecite: bool = True) -> CitationList:
        """Extract citations using both regex and eyecite methods."""
        if not text:
            return []
        
        citations = []
        
        regex_citations = self.extract_with_regex(text)
        citations.extend(regex_citations)
        
        if use_eyecite and EYECITE_AVAILABLE:
            eyecite_citations = self.extract_with_eyecite(text)
            citations.extend(eyecite_citations)
        
        return self._deduplicate_citations(citations)
    
    def _deduplicate_citations(self, citations: CitationList) -> CitationList:
        """Remove duplicate citations based on text and position."""
        seen = set()
        unique_citations = []
        
        for citation in citations:
            key = (citation.citation, citation.start_index, citation.end_index)
            if key not in seen:
                seen.add(key)
                unique_citations.append(citation)
        
        return unique_citations 