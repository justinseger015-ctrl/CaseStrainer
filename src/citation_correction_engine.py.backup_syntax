"""
Citation Correction Engine

This module provides suggestions for correcting invalid or unverified citations
by finding similar verified citations and applying intelligent correction rules.
"""

import sqlite3from src.config import DEFAULT_REQUEST_TIMEOUT, COURTLISTENER_TIMEOUT, CASEMINE_TIMEOUT, WEBSEARCH_TIMEOUT, SCRAPINGBEE_TIMEOUT

import logging
import re
import os
import sys
import traceback
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
import json
import time
from datetime import datetime
import warnings
from collections import defaultdict
import unicodedata

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

try:
    from src.citation_utils_consolidated import apply_washington_spacing_rules
except ImportError:
    from citation_utils_consolidated import apply_washington_spacing_rules

project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from .config import configure_logging

if not logging.getLogger().hasHandlers():
    configure_logging()

logger = logging.getLogger(__name__)

try:
    import Levenshtein
    LEVENSHTEIN_AVAILABLE = True
except ImportError:
    LEVENSHTEIN_AVAILABLE = False
    logger.warning("Warning: Levenshtein module not available, using difflib fallback")

import sys
from typing import List, Dict, Any
from difflib import SequenceMatcher
from .database_manager import get_database_manager

class CitationCorrectionEngine:
    """
    A system for suggesting corrections to invalid or unverified citations
    by finding similar verified citations and applying intelligent correction rules.
    """

    def __init__(self) -> None:
        """Initialize the correction engine."""
        self.db_path = os.path.join(
            os.path.dirname(os.path.abspath(__file__)), "citations.db"
        )
        self.cache_dir = os.path.join(
            os.path.dirname(os.path.abspath(__file__)), "correction_cache"
        )

        if not os.path.exists(self.cache_dir):
            os.makedirs(self.cache_dir)

        self._init_database()

    def suggest_corrections(self, citation: str, max_suggestions: int = 5, min_similarity: float = 0.7) -> Dict[str, Any]:
        """
        Suggest corrections for a potentially invalid citation.

        Args:
            citation: The citation to correct
            max_suggestions: Maximum number of suggestions to return
            min_similarity: Minimum similarity score (0-1) for suggestions

        Returns:
            Dictionary containing the original citation and a list of suggested corrections
        """
        if not citation:
            return {"citation": "", "suggestions": [], "error": "No citation provided"}

        if not isinstance(citation, str):
            try:
                citation = str(citation)
            except Exception as e:
                return {
                    "citation": "[invalid]" + str(citation)[:50],
                    "suggestions": [],
                    "error": f"Invalid citation format: {str(e)}",
                }

        try:
            logger.info(f"Processing citation: {citation}")
            normalized_citation = self._normalize_citation_comprehensive(citation, purpose="verification")

            if not normalized_citation or len(normalized_citation.strip()) < 3:
                return {
                    "citation": citation,
                    "suggestions": [],
                    "error": "Citation is too short or empty after normalization",
                }

            try:
                similar_citations = self._find_similar_citations(
                    citation, min_similarity
                )

                if similar_citations:
                    suggestions = [
                        {
                            "corrected_citation": item["citation"],
                            "similarity": item["similarity"],
                            "explanation": f"Similar to verified citation (confidence: {item['similarity']:.1%})",
                            "correction_type": "similar_verified",
                        }
                        for item in similar_citations[:max_suggestions]
                    ]
                    return {
                        "citation": citation,
                        "suggestions": suggestions,
                        "info": f"Found {len(similar_citations)} similar citations in database",
                    }

                logger.info(f"No similar citations found for: {citation}")

            except Exception as e:
                logger.warning(f"Error getting similar citations: {e}")

            suggestions = []

            if normalized_citation != citation:
                suggestions.append(
                    {
                        "corrected_citation": normalized_citation,
                        "similarity": 0.9,
                        "explanation": "Normalized citation format",
                        "correction_type": "normalization",
                    }
                )

            if "U.S." in normalized_citation or "US" in normalized_citation.upper():
                us_corrected = (
                    normalized_citation.replace("US", "U.S.")
                    .replace(" ", " ")
                    .replace("U.S.", "U.S. ")
                    .strip()
                )

                if us_corrected != normalized_citation:
                    suggestions.append(
                        {
                            "corrected_citation": us_corrected,
                            "similarity": 0.85,
                            "explanation": "Standardized U.S. Supreme Court citation format",
                            "correction_type": "format_standardization",
                        }
                    )

            return {"citation": citation, "suggestions": suggestions[:max_suggestions]}

        except re.error as e:
            logger.error(f"Regex error processing citation '{citation}': {str(e)}")
            return {
                "citation": citation,
                "suggestions": [],
                "error": f"Error processing citation format: {str(e)}",
            }
        except Exception as e:
            logger.error(f"Unexpected error processing citation '{citation}': {str(e)}")
            logger.error(traceback.format_exc())
            return {
                "citation": citation,
                "suggestions": [],
                "error": f"Error generating suggestions: {str(e)}",
            }

    def _normalize_citation_comprehensive(self, citation: str, purpose: str = "general") -> str:
        """
        Comprehensive citation normalization that replaces the deprecated _normalize_citation.
        
        Args:
            citation: The citation to normalize
            purpose: The purpose of normalization ("general", "bluebook", "verification", "comparison")
            
        Returns:
            The normalized citation
        """
        if not citation:
            return ""

        logger.info(f"Normalizing citation: {citation} (purpose: {purpose})")

        try:
            if not isinstance(citation, str):
                citation = str(citation)

            normalized = citation.strip()

            normalized = re.sub(r"\s+", " ", normalized)

            normalized = normalized.strip(" .,;:")

            normalized = apply_washington_spacing_rules(normalized)

            fed_reporter = re.match(r"^(\d+)\s+([A-Za-z\.\d]+)\s+(\d+)$", normalized)
            if fed_reporter:
                vol = fed_reporter.group(1)
                reporter = (
                    fed_reporter.group(2).upper().replace(" ", "")
                )  # Remove any spaces in reporter
                page = fed_reporter.group(3)
                return f"{vol} {reporter} {page}"

            us_reports = re.match(
                r"^(\d+)\s+U\.?\s*S\.?\s*(\d+)$", normalized, re.IGNORECASE
            )
            if us_reports:
                vol = us_reports.group(1)
                page = us_reports.group(2)
                return f"{vol} U.S. {page}"

            us_no_periods = re.match(r"^(\d+)\s+US\s+(\d+)$", normalized, re.IGNORECASE)
            if us_no_periods:
                vol = us_no_periods.group(1)
                page = us_no_periods.group(2)
                return f"{vol} U.S. {page}"

            wash_cites = re.match(
                r"^(\d+)\s+Wn\.?\s*(2d|App)?\s*(\d*)$", normalized, re.IGNORECASE
            )
            if wash_cites:
                vol = wash_cites.group(1)
                series = (
                    f" {wash_cites.group(2).upper()}" if wash_cites.group(2) else ""
                )
                page = f" {wash_cites.group(3)}" if wash_cites.group(3) else ""
                return f"{vol} WASH{series}{page}"


            normalized = re.sub(r"Wash\.\s*App\.", "Wn. App.", normalized)
            normalized = re.sub(r"Wash\.", "Wn.", normalized)

            normalized = re.sub(
                r"P\.\s*(\d+)(d|th)", r"P.\1\2", normalized, flags=re.IGNORECASE
            )  # P.2d, P.3d
            normalized = re.sub(
                r"F\.\s*(\d+)(d|th)", r"F.\1\2", normalized, flags=re.IGNORECASE
            )  # F.2d, F.3d

            normalized = re.sub(
                r"\.\s+(?=[a-z])", ".", normalized
            )  # Remove spaces after periods only before lowercase letters

            return normalized.strip()

        except Exception as e:
            logger.error(f"Error normalizing citation '{citation}': {str(e)}")
            return citation.strip()

    def _extract_citation_components(self, citation: str) -> Dict[str, Any]:
        """Extract components from a citation for flexible matching."""
        components = {"volume": "", "reporter": "", "page": "", "court": "", "year": ""}

        try:
            normalized = citation.upper()

            us_reports = re.match(
                r"^(\d+)\s+U\.?\s*S\.?\s*(\d+)", normalized, re.IGNORECASE
            )
            if us_reports:
                components["volume"] = us_reports.group(1)
                components["reporter"] = "U.S."
                components["page"] = us_reports.group(2)
                components["court"] = "United States Supreme Court"
                return components

            fed_reporter = re.match(
                r"^(\d+)\s+([A-Za-z\.\d]+)\s+(\d+)", normalized, re.IGNORECASE
            )
            if fed_reporter:
                components["volume"] = fed_reporter.group(1)
                reporter = (
                    fed_reporter.group(2).upper().replace(" ", "")
                )  # Remove any spaces in reporter

                reporter = re.sub(r"F(\d+)(D|d)", r"F.\1d", reporter)

                components["reporter"] = reporter
                components["page"] = fed_reporter.group(3)

                if any(rep in reporter.upper() for rep in ["F.2D", "F.3D"]):
                    components["court"] = "United States Court of Appeals"
                elif any(
                    rep in reporter.upper()
                    for rep in ["F.SUPP", "F.SUPP.2D", "F.SUPP.3D"]
                ):
                    components["court"] = "United States District Court"

                return components

            wash_cites = re.match(
                r"^(\d+)\s+WN\.?\s*(2D|APP)?\s*(\d*)", normalized, re.IGNORECASE
            )
            if wash_cites:
                components["volume"] = wash_cites.group(1)
                series = (
                    f" {wash_cites.group(2).upper()}" if wash_cites.group(2) else ""
                )
                components["reporter"] = f"WASH{series}"
                if wash_cites.group(3):
                    components["page"] = wash_cites.group(3)
                if "APP" in normalized:
                    components["court"] = "Washington Court of Appeals"
                else:
                    components["court"] = "Washington Supreme Court"
                return components

            volume_reporter_page = re.search(
                r"(\d+)\s+([A-Za-z\.\s]+?)(?:\s+(\d+))?\s*$", citation
            )
            if volume_reporter_page:
                components["volume"] = volume_reporter_page.group(1)
                components["reporter"] = volume_reporter_page.group(2).strip()
                if volume_reporter_page.group(3):
                    components["page"] = volume_reporter_page.group(3)

            year = re.search(r"\((\d{4})\)", citation)
            if year:
                components["year"] = year.group(1)

            if not components["court"]:
                if "WN. APP" in normalized or "WASH. APP" in normalized:
                    components["court"] = "Washington Court of Appeals"
                elif "WN." in normalized or "WASH." in normalized:
                    components["court"] = "Washington Supreme Court"
                elif "U.S." in normalized or "US " in normalized:
                    components["court"] = "United States Supreme Court"
                elif "F." in normalized:
                    if "SUPP." in normalized:
                        components["court"] = "United States District Court"
                    else:
                        components["court"] = "United States Court of Appeals"

        except Exception as e:
            logger.error(
                f"Error extracting components from citation '{citation}': {str(e)}"
            )
            logger.error(traceback.format_exc())

        return components

    def _init_database(self):
        """Initialize the database with required tables if they don't exist."""
        conn = None
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            cursor.execute("PRAGMA table_info(citations)")
            columns = [col[1] for col in cursor.fetchall()]

            if not columns or "citation_text" not in columns:
                cursor.execute("""DROP TABLE IF EXISTS citations""")

                cursor.execute(
                    """
                    CREATE TABLE citations (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        citation_text TEXT NOT NULL UNIQUE,
                        found BOOLEAN DEFAULT 1,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """
                )

                cursor.execute(
                    """
                    CREATE INDEX idx_citation_text ON citations (citation_text)
                """
                )

                cursor.execute(
                    """
                    CREATE INDEX idx_citation_found ON citations (found)
                """
                )

                self._seed_database(cursor)
            else:
                cursor.execute("""SELECT COUNT(*) FROM citations""")
                count = cursor.fetchone()[0]

                if count == 0:
                    self._seed_database(cursor)

            conn.commit()
            logger.info("Database initialized successfully")

        except sqlite3.Error as e:
            error_msg = f"Error initializing database: {e}"
            logging.error(error_msg)
            if conn:
                conn.rollback()
            raise RuntimeError(error_msg)
        finally:
            if conn:
                conn.close()

    def _seed_database(self, cursor: sqlite3.Cursor) -> None:
        """Seed the database with sample verified citations."""
        try:
            sample_citations = [
                "410 U.S. 113",  # Roe v. Wade
                "347 U.S. 483",  # Brown v. Board of Education
                "384 U.S. 436",  # Miranda v. Arizona
                "163 U.S. 537",  # Plessy v. Ferguson
                "5 U.S. 137",  # Marbury v. Madison
                "347 F.3d 123",
                "456 F.2d 789",
                "789 F.3d 456",
                "123 F.Supp.2d 456",
                "456 F.Supp.2d 789",
                "123 Wn.2d 456",
                "456 Wn. App. 789",
                "789 Wn.2d 123",
                "123 Wn. App. 456",
                "456 Wn. 789",
            ]

            for citation in sample_citations:
                try:
                    cursor.execute(
                        """
                        INSERT OR IGNORE INTO citations (citation_text, found)
                        VALUES (?, 1)
                    """,
                        (citation,),
                    )
                except Exception as e:
                    logger.warning(f"Could not insert citation {citation}: {e}")

            logger.info(
                f"Seeded database with {len(sample_citations)} sample citations"
            )

        except Exception as e:
            logger.error(f"Error seeding database: {e}")
            logger.error(traceback.format_exc())

    def _get_verified_citations(self):
        """
        Get all verified citations from the database.

        Returns:
            list: List of verified citation strings, or empty list if error occurs
        """
        try:
            self._init_database()

            db_manager = get_database_manager()

            tables = db_manager.execute_query("SELECT name FROM sqlite_master WHERE type='table' AND name='citations'")
            if not tables:
                logger.warning("Citations table does not exist in the database")
                return []

            columns = db_manager.execute_query("PRAGMA table_info(citations)")
            column_names = [col['name'] for col in columns]

            if "found" in column_names:
                query = "SELECT citation_text FROM citations WHERE found = 1"
            else:
                query = "SELECT citation_text FROM citations"
                logger.warning("'found' column not found, returning all citations")

            rows = db_manager.execute_query(query)
            verified_citations = [row["citation_text"] for row in rows if row and row["citation_text"]]

            logger.info(f"Retrieved {len(verified_citations)} verified citations from database")
            return verified_citations

        except Exception as e:
            logger.error(f"Unexpected error in _get_verified_citations: {e}")
            logger.error(traceback.format_exc())
            return []

    def _similarity_score(self, citation1: str, citation2: str) -> float:
        """Calculate similarity score between two citations."""
        norm1 = self._normalize_citation_comprehensive(citation1, purpose="similarity")
        norm2 = self._normalize_citation_comprehensive(citation2, purpose="similarity")

        if LEVENSHTEIN_AVAILABLE:
            distance = Levenshtein.distance(norm1, norm2)
            max_len = max(len(norm1), len(norm2))
            
            if max_len == 0:
                return 0.0
            
            similarity = 1.0 - (distance / max_len)
        else:
            similarity = SequenceMatcher(None, norm1, norm2).ratio()

        comp1 = self._extract_citation_components(citation1)
        comp2 = self._extract_citation_components(citation2)

        component_matches = 0
        component_total = 0

        for key in ["volume", "reporter", "page"]:
            if comp1[key] and comp2[key]:
                component_total += 1
                if comp1[key] == comp2[key]:
                    component_matches += 1

        if component_total > 0:
            component_similarity = component_matches / component_total
            similarity = (0.7 * similarity) + (0.3 * component_similarity)

        return similarity

    def _find_similar_citations(self, citation: str, threshold: float = 0.7) -> List[Dict[str, Any]]:
        """
        Find similar verified citations above a similarity threshold.

        Args:
            citation (str): The citation to find similar matches for
            threshold (float): Minimum similarity score (0-1) to consider a match

        Returns:
            list: List of dictionaries with 'citation' and 'similarity' keys,
                  sorted by similarity in descending order
        """
        if not citation or not isinstance(citation, str):
            logger.warning(f"Invalid citation provided: {citation}")
            return []

        logger.debug(
            f"Finding similar citations for: {citation} (threshold: {threshold})"
        )

        try:
            verified_citations = self._get_verified_citations()
            if not verified_citations:
                return []

            logger.debug(
                f"Comparing against {len(verified_citations)} verified citations"
            )

            similar_citations = []

            for verified_citation in verified_citations:
                try:
                    if not verified_citation or not isinstance(verified_citation, str):
                        continue

                    similarity = self._similarity_score(citation, verified_citation)

                    if similarity >= threshold:
                        similar_citations.append(
                            {"citation": verified_citation, "similarity": similarity}
                        )

                except Exception as e:
                    logger.warning(
                        f"Error comparing citations '{citation}' and '{verified_citation}': {e}"
                    )
                    continue

            similar_citations.sort(key=lambda x: x["similarity"], reverse=True)

            result_count = len(similar_citations)
            if result_count > 0:
                logger.debug(
                    f"Found {result_count} similar citations (best match: {similar_citations[0]['similarity']:.2f})"
                )
            else:

            return similar_citations

        except Exception as e:
            logger.error(f"Error in _find_similar_citations: {e}")
            return []

    def _apply_correction_rules(self, citation: str) -> str:
        """Apply correction rules to fix common citation errors."""
        corrected = citation

        corrected = apply_washington_spacing_rules(corrected)

        corrected = re.sub(
            r"(\d+)([A-Za-z])", r"\1 \2", corrected
        )  # Add space between number and letter
        corrected = re.sub(
            r"([A-Za-z])(\d+)", r"\1 \2", corrected
        )  # Add space between letter and number

        corrected = re.sub(r"Wash\.\s*App\.", "Wn. App.", corrected)
        corrected = re.sub(r"Wash\.", "Wn.", corrected)
        corrected = re.sub(r"Pac\.", "P.", corrected)
        corrected = re.sub(r"Fed\.", "F.", corrected)

        corrected = re.sub(r"P\s*(\d+\s*d)", r"P.\1", corrected)
        corrected = re.sub(r"P\s*(\d+)\s*th", r"P.\1d", corrected)
        corrected = re.sub(r"F\s*(\d+\s*d)", r"F.\1", corrected)
        corrected = re.sub(r"F\s*(\d+)\s*th", r"F.\1d", corrected)

        corrected = re.sub(
            r"(\b[A-Z][a-z]*)(\s)", r"\1.\2", corrected
        )  # Add period after abbreviations

        if " v " in corrected:
            corrected = corrected.replace(" v ", " v. ")

        return corrected

    def _check_database_initialized(self):
        """Check if the database is properly initialized with data."""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT COUNT(*) FROM citations WHERE found = 1")
            count = cursor.fetchone()[0]
            conn.close()
            return count > 0
        except Exception as e:
            logger.error(f"Error checking database: {e}")
            return False



    def batch_suggest_corrections(self, citations: List[str]) -> List[Dict[str, Any]]:
        """
        Suggest corrections for a batch of citations.
        Returns a list of correction suggestions.
        """
        results = []

        for citation in citations:
            result = self.suggest_corrections(citation)
            results.append(result)

        return results

    def apply_best_correction(self, citation: str) -> Dict[str, Any]:
        """
        Apply the best correction to a citation.
        Returns the corrected citation and an explanation.
        """
        suggestions = self.suggest_corrections(citation)

        if not suggestions["suggestions"]:
            return {
                "citation": citation,
                "corrected": False,
                "corrected_citation": citation,
                "explanation": "No corrections available",
            }

        best_suggestion = suggestions["suggestions"][0]

        return {
            "citation": citation,
            "corrected": True,
            "corrected_citation": best_suggestion["corrected_citation"],
            "similarity": best_suggestion["similarity"],
            "explanation": best_suggestion["explanation"],
            "correction_type": best_suggestion["correction_type"],
        }


if __name__ == "__main__":
    correction_engine = CitationCorrectionEngine()

    invalid_citations = [
        "410 US 113",  # Missing periods in U.S.
        "347US483",  # Missing spaces
        "198 Wash2d 271",  # Missing period
        "175WashApp1",  # Missing spaces and periods
        "123 P3d 456",  # Missing period
    ]

    for citation in invalid_citations:
        result = correction_engine.suggest_corrections(citation)
        logger.info(f"Citation: {citation}")
        logger.info(f"Suggestions: {len(result['suggestions'])}")

        for i, suggestion in enumerate(result["suggestions"]):
            logger.info(f"  {i+1}. {suggestion['corrected_citation']} (similarity: {suggestion['similarity']:.2f})"
            )
            logger.info(f"     Explanation: {suggestion['explanation']}")

        logger.info("")  # Empty message for spacing
